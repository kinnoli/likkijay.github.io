<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="utf-8">
        <title>My JavaScript Reference</title>
        <link href="styles/main.css" rel="stylesheet">
        <link rel="icon" href="images/js_reference_icon.ico">
        <script src="scripts/smooth-scroll.js"></script>
    </head>
    <body>
        <header class="header">
            <h1 class="heading header__title">JavaScript</h1>
            <nav class="header__nav">
                <ul>
                    <li class="dropdown-toggle"><a href="#general" class="navlink" data-scroll>Основная информация</a>
                        <ul class="dropdown">
                            <li><a href="#ext-scripts" class="navlink" data-scroll>Внешние скрипты, порядок исполнения</a></li>
                            <li><a href="#code-structure" class="navlink" data-scroll>Структура кода</a></li>
                            <li><a href="#use-strict" class="navlink" data-scroll>Современный стандарт, "use strict"</a></li>
                            <li><a href="#variables" class="navlink" data-scroll>Переменные</a></li>
                            <li><a href="#variables-names" class="navlink" data-scroll>Правильный выбор имени переменной</a></li>
                            <li><a href="#data-types" class="navlink" data-scroll>Шесть типов данных, typeof</a></li>
                            <li><a href="#types-conversion" class="navlink" data-scroll>Преобразование типов для примитивов</a></li>
                            <li><a href="#base-ui" class="navlink" data-scroll>Взаимодействие с пользователем: alert, prompt, confirm</a></li>
                        </ul>
                    </li>
                    <li class="dropdown-toggle"><a href="#operators" class="navlink" data-scroll>Операторы</a>
                        <ul class="dropdown">
                            <li><a href="#basic-operators" class="navlink" data-scroll>Основные операторы</a></li>
                            <li><a href="#comparison-operators" class="navlink" data-scroll>Операторы сравнения и логические значения</a></li>
                            <li><a href="#conditional-operators" class="navlink" data-scroll>Условные операторы: if, "?"</a></li>
                            <li><a href="#logic-operators" class="navlink" data-scroll>Логические операторы</a></li>
                        </ul>
                    </li>
                    <li class="dropdown-toggle"><a href="#functions" class="navlink" data-scroll>Функции</a>
                        <ul class="dropdown">
                            <li><a href="#while-for-cycles" class="navlink" data-scroll>Циклы while, for</a></li>
                        </ul>
                    </li>
                </ul>
            </nav>
        </header>
        <section class="section">
            <h1 class="heading section__title" id="general">Основная информация</h1>
            <article class="section__article">
                <h2 class="heading article__title" id="ext-scripts">Внешние скрипты, порядок исполнения</h2>
                <p>Если JavaScript-кода много – его выносят в отдельный файл, который подключается в HTML:</p>
                <code class="code-example">&lt;script src=&quot;/path/to/script.js&quot;&gt;&lt;/script&gt;</code>
                <p>Чтобы подключить несколько скриптов, используйте несколько тегов. Как правило, в HTML пишут только самые простые скрипты, а сложные выносят в отдельный файл. Браузер скачает его только первый раз и в дальнейшем, при правильной настройке сервера, будет брать из своего кеша. Благодаря этому один и тот же большой скрипт, содержащий, к примеру, библиотеку функций, может использоваться на разных страницах без полной перезагрузки с сервера.</p>
                <p>Если указан атрибут src, то содержимое тега игнорируется. В одном теге SCRIPT нельзя одновременно подключить внешний скрипт и указать код. Вот так не сработает:</p>
                <code class="code-example">
                    &lt;script src=&quot;file.js&quot;&gt;<br>
                    alert(1); // так как указан src, то внутренняя часть тега игнорируется<br>
                    &lt;/script&gt;
                </code>
                <p>Нужно выбрать: либо SCRIPT идёт с src, либо содержит код. Тег выше следует разбить на два: один – с src, другой – с кодом, вот так:</p>
                <code class="code-example">
                    &lt;script src=&quot;file.js&quot;&gt;&lt;/script&gt;<br>
                    &lt;script&gt;<br>
                    alert( 1 );<br>
                    &lt;/script&gt;
                </code>
                <h3 class="heading article__subheading">Асинхронные скрипты: defer/async</h3>
                <p>Браузер загружает и отображает HTML постепенно. Особенно это заметно при медленном интернет-соединении: браузер не ждёт, пока страница загрузится целиком, а показывает ту часть, которую успел загрузить. Если браузер видит тег &lt;script&gt;, то он по стандарту обязан сначала выполнить его, а потом показать оставшуюся часть страницы.</p>
                <p>Такое поведение называют &quot;синхронным&quot;. Как правило, оно вполне нормально, но есть важное следствие. Если скрипт – внешний, то пока браузер не выполнит его, он не покажет часть страницы под ним.</p>
                <p>Можно поставить все подобные скрипты в конец страницы – это уменьшит проблему, но не избавит от неё полностью, если скриптов несколько. Допустим, в конце страницы 3 скрипта, и первый из них тормозит – получается, другие два его будут ждать – тоже нехорошо.
                Кроме того, браузер дойдёт до скриптов, расположенных в конце страницы, они начнут грузиться только тогда, когда вся страница загрузится. А это не всегда правильно. Например, счётчик посещений наиболее точно сработает, если загрузить его пораньше. Поэтому &quot;расположить скрипты внизу&quot; – не лучший выход. Кардинально решить эту проблему помогут атрибуты async или defer:</p>
                <ul class="standart-list">
                    <li>
                        <p>Атрибут async - поддерживается всеми браузерами, кроме IE9-. Скрипт выполняется полностью асинхронно. То есть, при обнаружении &lt;script async src=&quot;...&quot;&gt; браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен – он выполнится.</p>
                    </li>
                    <li>
                        <p>Атрибут defer - поддерживается всеми браузерами, включая самые старые IE. Скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от async. Первое – браузер гарантирует, что относительный порядок скриптов с defer будет сохранён. То есть, в таком коде (с async) первым сработает тот скрипт, который раньше загрузится:</p>
                        <code class="code-example">
                            &lt;script src=&quot;1.js&quot; async&gt;&lt;/script&gt;<br>
                            &lt;script src=&quot;2.js&quot; async&gt;&lt;/script&gt;
                        </code>
                        <p>А в таком коде (с defer) первым сработает всегда 1.js, а скрипт 2.js, даже если загрузился раньше, будет его ждать:</p>
                        <code class="code-example">
                            &lt;script src=&quot;1.js&quot; defer&gt;&lt;/script&gt;<br>
                            &lt;script src=&quot;2.js&quot; defer&gt;&lt;/script&gt;
                        </code>
                        <p>Поэтому атрибут defer используют в тех случаях, когда второй скрипт 2.js зависит от первого 1.js, к примеру – использует что-то, описанное первым скриптом. Второе отличие – скрипт с defer сработает, когда весь HTML-документ будет обработан браузером. Например, если документ достаточно большой…</p>
                        <code class="code-example">
                            &lt;script src=&quot;async.js&quot; async&gt;&lt;/script&gt;<br>
                            &lt;script src=&quot;defer.js&quot; defer&gt;&lt;/script&gt;
                        </code>
                        <p>…То скрипт async.js выполнится, как только загрузится – возможно, до того, как весь документ готов. А defer.js подождёт готовности всего документа. Это бывает удобно, когда мы в скрипте хотим работать с документом, и должны быть уверены, что он полностью получен.</p>
                    </li>
                    <p>При одновременном указании async и defer в современных браузерах будет использован только async, в IE9- – только defer (не понимает async). Атрибуты async/defer работают только в том случае, если назначены на внешние скрипты, т.е. имеющие src. При попытке назначить их на обычные скрипты &lt;script&gt;…&lt;/script&gt;, они будут проигнороированы.</p>
                </ul>
            </article>
            <article class="section__article">
                <h2 class="heading article__title" id="code-structure">Структура кода</h2>
                <h3 class="heading article__subheading">Команды</h3>
                <p>Раньше мы уже видели пример команды: alert('Привет, мир!') выводит сообщение. Для того, чтобы добавить в код ещё одну команду – можно поставить её после точки с запятой. Например, вместо одного вызова alert сделаем два:</p>
                <code class="code-example">
                    alert('Привет'); alert('Мир');
                </code>
                <p>Как правило, каждая команда пишется на отдельной строке – так код лучше читается:</p>
                <code class="code-example">
                    alert('Привет');<br>
                    alert('Мир');
                </code>
                <h3 class="heading article__subheading">Точка с запятой</h3>
                <p>Точку с запятой во многих случаях можно не ставить, если есть переход на новую строку. Так тоже будет работать:</p>
                <code class="code-example">
                    alert('Привет')<br>
                    alert('Мир')
                </code>
                <p>В этом случае JavaScript интерпретирует переход на новую строчку как разделитель команд и автоматически вставляет &quot;виртуальную&quot; точку с запятой между ними. Однако, важно то, что &quot;во многих случаях&quot; не означает &quot;всегда&quot;!
                В некоторых важных ситуациях JavaScript "забывает" вставить точку с запятой там, где она нужна. Таких ситуаций не так много, но ошибки, которые при этом появляются, достаточно сложно обнаруживать и исправлять. Поэтому в JavaScript рекомендуется точки с запятой ставить. Сейчас это, фактически, стандарт, которому следуют все большие проекты.</p>
                <h3 class="heading article__subheading">Комментарии</h3>
                <p>Со временем программа становится большой и сложной. Появляется необходимость добавить комментарии, которые объясняют, что происходит и почему. Комментарии могут находиться в любом месте программы и никак не влияют на её выполнение. Интерпретатор JavaScript попросту игнорирует их. Однострочные комментарии начинаются с двойного слэша //. Текст считается комментарием до конца строки:</p>
                <code class="code-example">
                    // Команда ниже говорит "Привет"<br>
                    alert( 'Привет' );<br>
                    alert( 'Мир' ); // Второе сообщение выводим отдельно
                </code>
                <p>Многострочные комментарии начинаются слешем-звездочкой «/*» и заканчиваются звездочкой-слэшем «*/», вот так:</p>
                <code class="code-example">
                    /* Пример с двумя сообщениями.<br>
                    Это - многострочный комментарий.<br>
                    */<br>
                    alert( 'Привет' );<br>
                    alert( 'Мир' );
                </code>
                <p>Всё содержимое комментария игнорируется. Если поместить код внутрь /* … */ или после // – он не выполнится. Вложенные комментарии не поддерживаются! В этом коде будет ошибка:</p>
                <code class="code-example">
                    /*<br>
                        /* вложенный комментарий ?!? */<br>
                    */<br>
                    alert('Мир');
                </code>
            </article>
            <article class="section__article">
                <h2 class="heading article__title" id="use-strict">Современный стандарт, "use strict"</h2>
                <p>Очень долго язык JavaScript развивался без потери совместимости. Новые возможности добавлялись в язык, но старые – никогда не менялись, чтобы не "сломать" уже существующие HTML/JS-страницы с их использованием. Однако, это привело к тому, что любая ошибка в дизайне языка становилась "вмороженной" в него навсегда. Так было до появления стандарта ECMAScript 5 (ES5), который одновременно добавил новые возможности и внёс в язык ряд исправлений, которые могут привести к тому, что старый код, который был написан до его появления, перестанет работать. Чтобы этого не случилось, решили, что по умолчанию эти опасные изменения будут выключены, и код будет работать по-старому. А для того, чтобы перевести код в режим полного соответствия современному стандарту, нужно указать специальную директиву use strict. Эта директива не поддерживается IE9-.</p>
                <h3 class="heading article__subheading">Директива use strict</h3>
                <p>Директива выглядит как строка "use strict"; или 'use strict'; и ставится в начале скрипта. Например:</p>
                <code class="code-example">
                    "use strict";<br>
                    // этот код будет работать по современному стандарту ES5
                </code>
                <p>Отменить действие use strict никак нельзя. Не существует директивы no use strict или подобной, которая возвращает в старый режим. use strict также можно указывать в начале функций, тогда строгий режим будет действовать только внутри функции.</p>
                <p>Есть две проблемы.</p>
                <ul class="standart-list">
                    <li>
                        <p>Поддержка браузеров IE9-, которые игнорируют "use strict".</p>
                        <p>Предположим, что мы, используя "use strict", разработали код и протестировали его в браузере Chrome. Всё работает… Однако, вероятность ошибок при этом в IE9- выросла! Он-то всегда работает по старому стандарту, а значит, иногда по-другому. Возникающие ошибки придётся отлаживать уже в IE9-, и это намного менее приятно, нежели в Chrome.</p>
                    </li>
                    <li>
                        <p>Библиотеки, написанные без учёта "use strict".</p>
                        <p>Некоторые библиотеки, которые написаны без "use strict", не всегда корректно работают, если вызывающий код содержит "use strict". В первую очередь имеются в виду сторонние библиотеки, которые писали не мы, и которые не хотелось бы переписывать или править. Таких библиотек мало, но при переводе давно существующих проектов на "use strict" эта проблема возникает с завидной регулярностью.</p>
                    </li>
                </ul>
            </article>
            <article class="section__article">
                <h2 class="heading article__title" id="variables">Переменные</h2>
                <p>В зависимости от того, для чего вы делаете скрипт, понадобится работать с информацией. Чтобы хранить информацию, используются переменные. Переменная состоит из имени и выделенной области памяти, которая ему соответствует. Для объявления или, другими словами, создания переменной используется ключевое слово var. После объявления, можно записать в переменную данные:</p>
                <code class="code-example">
                    var message;<br>
                    message = 'Hello'; // сохраним в переменной строку
                </code>
                <p>Эти данные будут сохранены в соответствующей области памяти и в дальнейшем доступны при обращении по имени:</p>
                <code class="code-example">
                    var message;<br>
                    message = 'Hello!';<br>
                    alert( message ); // выведет содержимое переменной
                </code>
                <p>Для краткости можно совместить объявление переменной и запись данных, можно даже объявить несколько переменных сразу:</p>
                <code class="code-example">
                    var user = 'John', age = 25, message = 'Hello';
                </code>
                <p>Значение в переменной можно изменять сколько угодно раз:</p>
                <code class="code-example">
                    var message;<br>
                    message = 'Hello!';<br>
                    message = 'World!'; // заменили значение<br>
                    alert( message );
                </code>
                <p>При изменении значения старое содержимое переменной удаляется. Можно объявить две переменные и копировать данные из одной в другую:</p>
                <code class="code-example">
                    var hello = 'Hello world!';<br>
                    var message;<br>
                    // скопировали значение<br>
                    message = hello;<br>
                    alert( hello ); // Hello world!<br>
                    alert( message ); // Hello world!
                </code>
                <h3 class="heading article__subheading">Имена переменных</h3>
                <p>На имя переменной в JavaScript наложены всего два ограничения.</p>
                <p>1. Имя может состоять из: букв, цифр, символов $ и _</p>
                <p>2. Первый символ не должен быть цифрой.</p>
                <p>Например:</p>
                <code class="code-example">
                    var myName;<br>
                    var test123;
                </code>
                <p>Доллар '$' и знак подчеркивания '_' являются такими же обычными символами, как буквы:</p>
                <code class="code-example">
                    var $ = 1; // объявили переменную с именем '$'<br>
                    var _ = 2; // переменная с именем '_'<br>
                    alert( $ + _ ); // 3
                </code>
                <p>А такие переменные были бы неправильными:</p>
                <code class="code-example">
                    var 1a; // начало не может быть цифрой<br>
                    var my-name; // дефис '-' не является разрешенным символом
                </code>
                <p>Регистр букв имеет значение. Переменные apple и AppLE – две разные переменные. Русские буквы допустимы, но не рекомендуются. Существует список зарезервированных слов, которые нельзя использовать для переменных, так как они используются самим языком, например: var, class, return, export и др. Например, такой пример выдаст синтаксическую ошибку:</p>
                <code class="code-example">
                    var return = 5; // ошибка<br>
                    alert(return);
                </code>
                <h3 class="heading article__subheading">Важность директивы var</h3>
                <p>В старом стандарте JavaScript разрешалось создавать переменную и без var, просто присвоив ей значение:</p>
                <code class="code-example">
                    num = 5; // переменная num будет создана, если ее не было
                </code>
                <p>В режиме "use strict" так делать уже нельзя. Следующий код выдаст ошибку:</p>
                <code class="code-example">
                    "use strict";<br>
                    num = 5; // error: num is not defined
                </code>
                <p>Директиву use strict нужно ставить до кода, иначе она не сработает:</p>
                <code class="code-example">
                    var something;<br>
                    "use strict"; // слишком поздно<br>
                    num = 5; // ошибки не будет, так как строгий режим не активирован
                </code>
                <h3 class="heading article__subheading">Константы</h3>
                <p>Константа – это переменная, которая никогда не меняется. Как правило, их называют большими буквами, через подчёркивание. Например:</p>
                <code class="code-example">
                    var COLOR_RED = "#F00";<br>
                    var COLOR_GREEN = "#0F0";<br>
                    var COLOR_BLUE = "#00F";<br>
                    var COLOR_ORANGE = "#FF7F00";<br>
                    var color = COLOR_ORANGE;<br>
                    alert( color ); // #FF7F00
                </code>
                <p>Технически, константа является обычной переменной, то есть её можно изменить. Но мы договариваемся этого не делать. Зачем нужны константы? Почему бы просто не писать var color = "#FF7F00"?</p>
                <p>1. Во-первых, константа COLOR_ORANGE – это понятное имя. По присвоению var color="#FF7F00" непонятно, что цвет – оранжевый. Иными словами, константа COLOR_ORANGE является «понятным псевдонимом» для значения #FF7F00.</p>
                <p>2. Во-вторых, опечатка в строке, особенно такой сложной как #FF7F00, может быть не замечена, а в имени константы её допустить куда сложнее.</p>
                <p>Константы используют вместо строк и цифр, чтобы сделать программу понятнее и избежать ошибок.</p>
            </article>
            <article class="section__article">
                <h2 class="heading article__title" id="variables-names">Правильный выбор имени переменной</h2>
                <h3 class="heading article__subheading">Правила именования</h3>
                <p><strong>Правило 1.</strong> Никакого транслита. Только английский.</p>
                <p>Неприемлемы:</p>
                <code class="code-example">
                    var moiTovari;<br>
                    var cena;<br>
                    var ssilka;
                </code>
                <p>Подойдут:</p>
                <code class="code-example">
                    var myGoods;<br>
                    var price;<br>
                    var link;
                </code>
                <p>Во-первых, среди разработчиков всего мира принято использовать английский язык для имён переменных. И если ваш код потом попадёт к кому-то другому, например вы будете в команде больше чем из одного человека, то велик шанс, что транслит ему не понравится.</p>
                <p>Во-вторых, русский транслит хуже читается и длиннее, чем названия на английском.</p>
                <p>В-третьих, в проектах вы наверняка будете применять библиотеки, написанные другими людьми. Многое уже готово, в распоряжении современного разработчика есть масса инструментов, все они используют названия переменных и функций на английском языке, и вы, конечно, будете их использовать.</p>
                <p><strong>Правило 2.</strong> Использовать короткие имена только для переменных "местного значения".</p>
                <p>Называть переменные именами, не несущими смысловой нагрузки, например a, e, p, mg – можно только в том случае, если они используются в небольшом фрагменте кода и их применение очевидно. Вообще же, название переменной должно быть понятным. Иногда для этого нужно использовать несколько слов.</p>
                <p><strong>Правило 3.</strong> Переменные из нескольких слов пишутся вместеВотТак.</p>
                <p>Например:</p>
                <code class="code-example">
                    var borderLeftWidth;
                </code>
                <p>Этот способ записи называется "верблюжьей нотацией" или, по-английски, "camelCase". Существует альтернативный стандарт, когда несколько слов пишутся через знак подчеркивания '_':</p>
                <code class="code-example">
                    var border_left_width;
                </code>
                <p>Преимущественно в JavaScript используется вариант borderLeftWidth, в частности во встроенных языковых и браузерных функциях. Поэтому целесообразно остановиться на нём. Ещё одна причина выбрать «верблюжью нотацию» – запись в ней немного короче, чем с подчеркиванием, т.к. не нужно вставлять '_'.</p>
                <p><strong>Правило 4.</strong> Имя переменной должно максимально чётко соответствовать хранимым в ней данным.</p>
                <p>Смысл имени переменной – это "имя на коробке", по которому мы сможем максимально быстро находить нужные нам данные. Не нужно бояться переименовывать переменные, если вы придумали имя получше.</p>
            </article>
            <article class="section__article">
                <h2 class="heading article__title" id="data-types">Шесть типов данных, typeof</h2>
                <h3 class="heading article__subheading">Число "number"</h3>
                <code class="code-example">
                    var n = 123;<br>
                    n = 12.345;
                </code>
                <p>Единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений). Например, бесконечность Infinity получается при делении на ноль:</p>
                <code class="code-example">
                    alert( 1 / 0 ); // Infinity
                </code>
                <p>Ошибка вычислений NaN будет результатом некорректной математической операции, например:</p>
                <code class="code-example">
                    alert( "нечисло" * 2 ); // NaN, ошибка
                </code>
                <h3 class="heading article__subheading">Строка "string"</h3>
                <code class="code-example">
                    var str = "Мама мыла раму";<br>
                    str = 'Одинарные кавычки тоже подойдут';
                </code>
                <h3 class="heading article__subheading">Булевый (логический) тип "boolean"</h3>
                <p>У него всего два значения: true (истина) и false (ложь). Как правило, такой тип используется для хранения значения типа да/нет, например:</p>
                <code class="code-example">
                    var checked = true; // поле формы помечено галочкой<br>
                    checked = false;    // поле формы не содержит галочки
                </code>
                <h3 class="heading article__subheading">Специальное значение "null"</h3>
                <p>Значение null не относится ни к одному из типов выше, а образует свой отдельный тип, состоящий из единственного значения null:</p>
                <code class="code-example">
                    var age = null;
                </code>
                <p>Это просто специальное значение, которое имеет смысл "ничего" или "значение неизвестно". В частности, код выше говорит о том, что возраст age неизвестен.</p>
                <h3 class="heading article__subheading">Специальное значение "undefined"</h3>
                <p>Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл "значение не присвоено". Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined:</p>
                <code class="code-example">
                    var x;<br>
                    alert( x ); // выведет "undefined"
                </code>
                <p>Можно присвоить undefined и в явном виде, хотя это делается редко:</p>
                <code class="code-example">
                    var x = 123;<br>
                    x = undefined;<br>
                    alert( x ); // "undefined"
                </code>
                <p>В явном виде undefined обычно не присваивают, так как это противоречит его смыслу. Для записи в переменную "пустого" или "неизвестного" значения используется null.</p>
                <h3 class="heading article__subheading">Объекты "object"</h3>
                <p>Первые 5 типов называют "примитивными". Особняком стоит шестой тип: "объекты". Он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок {...}, например:</p>
                <code class="code-example">
                    var user = { name: "Вася" };
                </code>
                <h3 class="heading article__subheading">Оператор typeof</h3>
                <p>Оператор typeof возвращает тип аргумента. У него есть два синтаксиса: со скобками и без:</p>
                <p>1. Синтаксис оператора: typeof x.</p>
                <p>2. Синтаксис функции: typeof(x).</p>
                <p>Работают они одинаково, но первый синтаксис короче. Результатом typeof является строка, содержащая тип:</p>
                <code class="code-example">
                    typeof undefined // "undefined"<br>
                    typeof 0 // "number"<br>
                    typeof true // "boolean"<br>
                    typeof "foo" // "string"<br>
                    typeof {} // "object"<br>
                    typeof null // "object"<br>
                    typeof function(){} // "function"
                </code>
            </article>
            <article class="section__article">
                <h2 class="heading article__title" id="types-conversion">Преобразование типов для примитивов</h2>
                <p>Система преобразования типов в JavaScript очень проста. Всего есть три преобразования:</p>
                <p>1. Строковое преобразование.</p>
                <p>2. Числовое преобразование.</p>
                <p>3. Преобразование к логическому значению.</p>
                <h3 class="heading article__subheading">Строковое преобразование</h3>
                <p>Строковое преобразование происходит, когда требуется представление чего-либо в виде строки. Например, его производит функция alert.</p>
                <code class="code-example">
                    var a = true;<br>
                    alert( a ); // "true"
                </code>
                <p>Можно также осуществить преобразование явным вызовом String(value):</p>
                <code class="code-example">
                    alert( String(null) === "null" ); // true
                </code>
                <p>Как видно из примеров выше, преобразование происходит наиболее очевидным способом, «как есть»: false становится "false", null – "null", undefined – "undefined" и т.п. Также для явного преобразования применяется оператор бинарный "+", у которого один из аргументов строка. В этом случае он приводит к строке и другой аргумент, например:</p>
                <code class="code-example">
                    alert( true + "test" ); // "truetest"<br>
                    alert( "123" + undefined ); // "123undefined"
                </code>
                <h3 class="heading article__subheading">Численное преобразование</h3>
                <p>Численное преобразование происходит в математических функциях и выражениях, а также при сравнении данных различных типов (кроме сравнений ===, !==). Для преобразования к числу в явном виде можно вызвать Number(value), либо, поставить перед выражением унарный плюс "+":</p>
                <code class="code-example">
                    var a = +"123"; // 123<br>
                    var a = Number("123"); // 123, тот же эффект
                </code>
                <p>Значения преобразуются:</p>
                <ul class="standart-list">
                    <li>undefined ---> NaN</li>
                    <li>null ---> 0</li>
                    <li>true/false ---> 1/0</li>
                    <li>строка ---> Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.</li>
                </ul>
                <p>Например:</p>
                <code class="code-example">
                    // после обрезания пробельных символов останется "123"<br>
                    alert( +"   \n  123   \n  \n" ); // 123<br>
                    alert( +true ); // 1<br>
                    alert( +false ); // 0<br>
                    alert( "\n0 " == 0 ); // true
                </code>
                <p>Значения undefined/null преобразуются к числу при арифметических операциях и сравнениях > >= < <=, но не при проверке равенства ==.</p>
                <h3 class="heading article__subheading">Логическое преобразование</h3>
                <p>Явное преобразование:</p>
                <p>!!value</p>
                <p>Boolean(value)</p>
                <p>В логическом контексте:</p>
                <p>if(value)</p>
                <p>Значения преобразуются:</p>
                <ul class="standart-list">
                    <li>undefined, null ---> false</li>
                    <li>числа ---> true (кроме 0 и NaN)</li>
                    <li>строки ---> true (кроме пустой строки "")</li>
                    <li>объекты ---> true</li>
                </ul>
            </article>
            <article class="section__article">
                <h2 class="heading article__title" id="base-ui">Взаимодействие с пользователем: alert, prompt, confirm</h2>
                <h3 class="heading article__subheading">alert</h3>
                <p>alert выводит на экран окно с сообщением и приостанавливает выполнение скрипта, пока пользователь не нажмёт "ОК".</p>
                <code class="code-example">
                    alert(сообщение)
                </code>
                <p>Окно сообщения, которое выводится, является модальным окном. Слово "модальное" означает, что посетитель не может взаимодействовать со страницей, нажимать другие кнопки и т.п., пока не разберётся с окном. В данном случае – пока не нажмёт на "OK".</p>
                <h3 class="heading article__subheading">prompt</h3>
                <p>Функция prompt принимает два аргумента:</p>
                <code class="code-example">
                    result = prompt(title, default);
                </code>
                <p>Она выводит модальное окно с заголовком title, полем для ввода текста, заполненным строкой по умолчанию default и кнопками OK/CANCEL. Пользователь должен либо что-то ввести и нажать OK, либо отменить ввод кликом на CANCEL или нажатием Esc на клавиатуре. Вызов prompt возвращает то, что ввёл посетитель – строку или специальное значение null, если ввод отменён. Как и в случае с alert, окно prompt модальное.</p>
                <code class="code-example">
                    var years = prompt('Сколько вам лет?', 100);<br>
                    alert('Вам ' + years + ' лет!')
                </code>
                <h3 class="heading article__subheading">confirm</h3>
                <p>confirm выводит окно с вопросом question с двумя кнопками: OK и CANCEL. Результатом будет true при нажатии OK и false – при CANCEL(Esc). Например:</p>
                <code class="code-example">
                    var isAdmin = confirm("Вы - администратор?");<br>
                    alert( isAdmin );
                </code>
                <h3 class="heading article__subheading">Особенности встроенных функций</h3>
                <p>Конкретное место, где выводится модальное окно с вопросом – обычно это центр браузера, и внешний вид окна выбирает браузер. Разработчик не может на это влиять. С одной стороны – это недостаток, так как нельзя вывести окно в своем, особо красивом, дизайне. С другой стороны, преимущество этих функций по сравнению с другими, более сложными методами взаимодействия, которые мы изучим в дальнейшем – как раз в том, что они очень просты. Это самый простой способ вывести сообщение или получить информацию от посетителя. Поэтому их используют в тех случаях, когда простота важна, а всякие «красивости» особой роли не играют.</p>
            </article>
        </section>
        
        <section class="section">
            <h1 class="heading section__title" id="operators">Операторы</h1>
            <article class="section__article">
                <h2 class="heading article__title" id="basic-operators">Основные операторы</h2>
                <h3 class="heading article__subheading">Термины: "унарный", "бинарный", "операнд"</h3>
                <p>У операторов есть своя терминология, которая используется во всех языках программирования.</p>
                <ul class="standart-list">
                    <li><p>Операнд – то, к чему применяется оператор. Например: 5 * 2 – оператор умножения с левым и правым операндами. Другое название: "аргумент оператора".</p></li>
                    <li>
                        <p>Унарным называется оператор, который применяется к одному выражению. Например, оператор унарный минус "-" меняет знак числа на противоположный:</p>
                        <code class="code-example">
                            var x = 1;<br>
                            x = -x;<br>
                            alert( x ); // -1, применили унарный минус
                        </code>
                    </li>
                    <li>
                        <p>Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:</p>
                        <code class="code-example">
                            var x = 1, y = 3;<br>
                            alert( y - x ); // 2, бинарный минус
                        </code>
                    </li>
                </ul>
                <h3 class="heading article__subheading">Сложение строк, бинарный +</h3>
                <p>Обычно при помощи плюса '+' складывают числа. Но если бинарный оператор '+' применить к строкам, то он их объединяет в одну:</p>
                <code class="code-example">
                    var a = "моя" + "строка";<br>
                    alert( a ); // моястрока
                </code>
                <p>Иначе говорят, что "плюс производит конкатенацию (сложение) строк". Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке! Причем не важно, справа или слева находится операнд-строка, в любом случае нестроковый аргумент будет преобразован. Например:</p>
                <code class="code-example">
                    alert( '1' + 2 ); // "12"<br>
                    alert( 2 + '1' ); // "21"
                </code>
                <p>Это приведение к строке – особенность исключительно бинарного оператора "+". Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу. Например:</p>
                <code class="code-example">
                    alert( 2 - '1' ); // 1<br>
                    alert( 6 / '2' ); // 3
                </code>
                <h3 class="heading article__subheading">Преобразование к числу, унарный плюс +</h3>
                <p>Унарный, то есть применённый к одному значению, плюс ничего не делает с числами:</p>
                <code class="code-example">
                    alert( +1 ); // 1<br>
                    alert( +(1 - 2) ); // -1
                </code>
                <p>Как видно, плюс ничего не изменил в выражениях. Результат – такой же, как и без него. Тем не менее, он широко применяется, так как его "побочный эффект" – преобразование значения в число. Например, когда мы получаем значения из HTML-полей или от пользователя, то они обычно в форме строк. А что, если их нужно, к примеру, сложить? Бинарный плюс сложит их как строки:</p>
                <code class="code-example">
                    var apples = "2";<br>
                    var oranges = "3";<br>
                    alert( apples + oranges ); // "23", так как бинарный плюс складывает строки
                </code>
                <p>Поэтому используем унарный плюс, чтобы преобразовать к числу:</p>
                <code class="code-example">
                    var apples = "2";<br>
                    var oranges = "3";<br>
                    alert( +apples + +oranges ); // 5, число, оба операнда предварительно преобразованы в числа
                </code>
                <h3 class="heading article__subheading">Приоритет</h3>
                <p>В том случае, если в выражении есть несколько операторов – порядок их выполнения определяется приоритетом. В JavaScript существует целая таблица приоритетов. В ней каждому оператору задан числовой приоритет. Тот, у кого число больше – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.</p>
                <table class="standart-table">
                    <tbody>
                    <tr>
                        <th>Precedence</th>
                        <th>Operator type</th>
                        <th>Associativity</th>
                        <th>Individual operators</th>
                    </tr>
                    <tr>
                        <td>20</td>
                        <td>Grouping</td>
                        <td>n/a</td>
                        <td>( … )</td>
                    </tr>
                    <tr>
                        <td rowspan="3">19</td>
                        <td>Member Access</td>
                        <td>left-to-right</td>
                        <td>… . …</td>
                    </tr>
                    <tr>
                        <td>Computed Member Access</td>
                        <td>left-to-right</td>
                        <td>… [ … ]</td>
                    </tr>
                    <tr>
                        <td>new (with argument list)</td>
                        <td>n/a</td>
                        <td>new … ( … )</td>
                    </tr>
                    <tr>
                        <td rowspan="2">18</td>
                        <td>Function Call</td>
                        <td>left-to-right</td>
                        <td>… ( … )</td>
                    </tr>
                    <tr>
                        <td>new (without argument list)</td>
                        <td>right-to-left</td>
                        <td>new …</td>
                    </tr>
                    <tr>
                        <td rowspan="2">17</td>
                        <td>Postfix Increment</td>
                        <td>n/a</td>
                        <td>… ++</td>
                    </tr>
                    <tr>
                        <td>Postfix Decrement</td>
                        <td>n/a</td>
                        <td>… --</td>
                    </tr>
                    <tr>
                        <td rowspan="9">16</td>
                        <td>Logical NOT</td>
                        <td>right-to-left</td>
                        <td>! …</td>
                    </tr>
                    <tr>
                        <td>Bitwise NOT</td>
                        <td>right-to-left</td>
                        <td>~ …</td>
                    </tr>
                    <tr>
                        <td>Unary Plus</td>
                        <td>right-to-left</td>
                        <td>+ …</td>
                    </tr>
                    <tr>
                        <td>Unary Negation</td>
                        <td>right-to-left</td>
                        <td>- …</td>
                    </tr>
                    <tr>
                        <td>Prefix Increment</td>
                        <td>right-to-left</td>
                        <td>++ …</td>
                    </tr>
                    <tr>
                        <td>Prefix Decrement</td>
                        <td>right-to-left</td>
                        <td>-- …</td>
                    </tr>
                    <tr>
                        <td>typeof</td>
                        <td>right-to-left</td>
                        <td>typeof …</td>
                    </tr>
                    <tr>
                        <td>void</td>
                        <td>right-to-left</td>
                        <td>void …</td>
                    </tr>
                    <tr>
                        <td>delete</td>
                        <td>right-to-left</td>
                        <td>delete …</td>
                    </tr>
                    <tr>
                        <td>15</td>
                        <td>Exponentiation</td>
                        <td>right-to-left</td>
                        <td>… ** …</td>
                    </tr>
                    <tr>
                        <td rowspan="3">14</td>
                        <td>Multiplication</td>
                        <td>left-to-right</td>
                        <td>… * …</td>
                    </tr>
                    <tr>
                        <td>Division</td>
                        <td>left-to-right</td>
                        <td>… / …</td>
                    </tr>
                    <tr>
                        <td>Remainder</td>
                        <td>left-to-right</td>
                        <td>… % …</td>
                    </tr>
                    <tr>
                        <td rowspan="2">13</td>
                        <td>Addition</td>
                        <td>left-to-right</td>
                        <td>… + …</td>
                    </tr>
                    <tr>
                        <td>Subtraction</td>
                        <td>left-to-right</td>
                        <td>… - …</td>
                    </tr>
                    <tr>
                        <td rowspan="3">12</td>
                        <td>Bitwise Left Shift</td>
                        <td>left-to-right</td>
                        <td>… &lt;&lt; …</td>
                    </tr>
                    <tr>
                        <td>Bitwise Right Shift</td>
                        <td>left-to-right</td>
                        <td>… &gt;&gt; …</td>
                    </tr>
                    <tr>
                        <td>Bitwise Unsigned Right Shift</td>
                        <td>left-to-right</td>
                        <td>… &gt;&gt;&gt; …</td>
                    </tr>
                    <tr>
                        <td rowspan="6">11</td>
                        <td>Less Than</td>
                        <td>left-to-right</td>
                        <td>… &lt; …</td>
                    </tr>
                    <tr>
                        <td>Less Than Or Equal</td>
                        <td>left-to-right</td>
                        <td>… &lt;= …</td>
                    </tr>
                    <tr>
                        <td>Greater Than</td>
                        <td>left-to-right</td>
                        <td>… &gt; …</td>
                    </tr>
                    <tr>
                        <td>Greater Than Or Equal</td>
                        <td>left-to-right</td>
                        <td>… &gt;= …</td>
                    </tr>
                    <tr>
                        <td>in</td>
                        <td>left-to-right</td>
                        <td>… in …</td>
                    </tr>
                    <tr>
                        <td>instanceof</td>
                        <td>left-to-right</td>
                        <td>… instanceof …</td>
                    </tr>
                    <tr>
                        <td rowspan="4">10</td>
                        <td>Equality</td>
                        <td>left-to-right</td>
                        <td>… == …</td>
                    </tr>
                    <tr>
                        <td>Inequality</td>
                        <td>left-to-right</td>
                        <td>… != …</td>
                    </tr>
                    <tr>
                        <td>Strict Equality</td>
                        <td>left-to-right</td>
                        <td>… === …</td>
                    </tr>
                    <tr>
                        <td>Strict Inequality</td>
                        <td>left-to-right</td>
                        <td>… !== …</td>
                    </tr>
                    <tr>
                        <td>9</td>
                        <td>Bitwise AND</td>
                        <td>left-to-right</td>
                        <td>… &amp; …</td>
                    </tr>
                    <tr>
                        <td>8</td>
                        <td>Bitwise XOR</td>
                        <td>left-to-right</td>
                        <td>… ^ …</td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>Bitwise OR</td>
                        <td>left-to-right</td>
                        <td>… | …</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>Logical AND</td>
                        <td>left-to-right</td>
                        <td>… &amp;&amp; …</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>Logical OR</td>
                        <td>left-to-right</td>
                        <td>… || …</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>Conditional</td>
                        <td>right-to-left</td>
                        <td>… ? … : …</td>
                    </tr>
                    <tr>
                        <td rowspan="13">3</td>
                        <td rowspan="13">Assignment</td>
                        <td rowspan="13">right-to-left</td>
                        <td>… = …</td>
                    </tr>
                    <tr>
                        <td>… += …</td>
                    </tr>
                    <tr>
                        <td>… -= …</td>
                    </tr>
                    <tr>
                        <td>… **= …</td>
                    </tr>
                    <tr>
                        <td>… *= …</td>
                    </tr>
                    <tr>
                        <td>… /= …</td>
                    </tr>
                    <tr>
                        <td>… %= …</td>
                    </tr>
                    <tr>
                        <td>… &lt;&lt;= …</td>
                    </tr>
                    <tr>
                        <td>… &gt;&gt;= …</td>
                    </tr>
                    <tr>
                        <td>… &gt;&gt;&gt;= …</td>
                    </tr>
                    <tr>
                        <td>… &amp;= …</td>
                    </tr>
                    <tr>
                        <td>… ^= …</td>
                    </tr>
                    <tr>
                        <td>… |= …</td>
                    </tr>
                    <tr>
                        <td rowspan="2">2</td>
                        <td>yield</td>
                        <td>right-to-left</td>
                        <td>yield …</td>
                    </tr>
                    <tr>
                        <td>yield*</td>
                        <td>right-to-left</td>
                        <td>yield* …</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>Spread</td>
                        <td>n/a</td>
                        <td>... …</td>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>Comma / Sequence</td>
                        <td>left-to-right</td>
                        <td>… , …</td>
                    </tr>
                    </tbody>
                </table>
                <h3 class="heading article__subheading">Присваивание</h3>
                <p>У оператора присваивания – один из самых низких приоритетов: 3. Именно поэтому, когда переменную чему-либо присваивают, например, x = 2 * 2 + 1 сначала выполнится арифметика, а уже затем – произойдёт присваивание =.</p>
                <code class="code-example">
                    var x = 2 * 2 + 1;<br>
                    alert( x ); // 5
                </code>
                <p>Возможно присваивание по цепочке:</p>
                <code class="code-example">
                    var a, b, c;<br>
                    a = b = c = 2 + 2;<br>
                    alert( a ); // 4<br>
                    alert( b ); // 4<br>
                    alert( c ); // 4
                </code>
                <p>Такое присваивание работает справа-налево, то есть сначала вычислятся самое правое выражение 2+2, присвоится в c, затем выполнится b = c и, наконец, a = b. Все операторы возвращают значение. Вызов x = выражение не является исключением. Он записывает выражение в x, а затем возвращает его. Благодаря этому присваивание можно использовать как часть более сложного выражения:</p>
                <code class="code-example">
                    var a = 1;<br>
                    var b = 2;<br>
                    var c = 3 - (a = b + 1);<br>
                    alert( a ); // 3<br>
                    alert( c ); // 0
                </code>
                <p>В примере выше результатом (a = b + 1) является значение, которое записывается в a (т.е. 3). Оно используется для вычисления c.</p>
                <h3 class="heading article__subheading">Взятие остатка %</h3>
                <p>Оператор взятия остатка % интересен тем, что, несмотря на обозначение, никакого отношения к процентам не имеет. Его результат a % b – это остаток от деления a на b. Например:</p>
                <code class="code-example">
                    alert( 5 % 2 ); // 1, остаток от деления 5 на 2<br>
                    alert( 8 % 3 ); // 2, остаток от деления 8 на 3<br>
                    alert( 6 % 3 ); // 0, остаток от деления 6 на 3
                </code>
                <h3 class="heading article__subheading">Инкремент/декремент: ++, --</h3>
                <p>Одной из наиболее частых операций в JavaScript, как и во многих других языках программирования, является увеличение или уменьшение переменной на единицу. Для этого существуют специальные операторы:</p>
                <p>Инкремент ++ увеличивает на 1:</p>
                <code class="code-example">
                    var i = 2;<br>
                    i++;      // более короткая запись для i = i + 1.<br>
                    alert(i); // 3
                </code>
                <p>Декремент -- уменьшает на 1:</p>
                <code class="code-example">
                    var i = 2;<br>
                    i--;      // более короткая запись для i = i - 1.<br>
                    alert(i); // 1
                </code>
                <p>Инкремент/декремент можно применить только к переменной. Код 5++ даст ошибку.</p>
                <p>Вызывать эти операторы можно не только после, но и перед переменной: i++ (называется "постфиксная форма") или ++i ("префиксная форма"). Обе эти формы записи делают одно и то же: увеличивают на 1. Тем не менее, между ними существует разница. Она видна только в том случае, когда мы хотим не только увеличить/уменьшить переменную, но и использовать результат в том же выражении. Например:</p>
                <code class="code-example">
                    var i = 1;<br>
                    var a = ++i; // (*)<br>
                    alert(a); // 2
                </code>
                <p>В строке (*) вызов ++i увеличит переменную, а затем вернёт ее значение в a. Так что в a попадёт значение i после увеличения. Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения. В примере ниже в a попадёт старое значение i, равное 1:</p>
                <code class="code-example">
                    var i = 1;<br>
                    var a = i++; // (*)<br>
                    alert(a); // 1
                </code>
                <p>Если результат оператора не используется, а нужно только увеличить/уменьшить переменную – без разницы, какую форму использовать:</p>
                <code class="code-example">
                    var i = 0;<br>
                    i++;<br>
                    ++i;<br>
                    alert( i ); // 2
                </code>
                <p>Если хочется тут же использовать результат, то нужна префиксная форма:</p>
                <code class="code-example">
                    var i = 0;<br>
                    alert( ++i ); // 1
                </code>
                <p>Если нужно увеличить, но нужно значение переменной до увеличения – постфиксная форма:</p>
                <code class="code-example">
                    var i = 0;<br>
                    alert( i++ ); // 0
                </code>
                <p>Инкремент/декремент можно использовать в любых выражениях. При этом он имеет более высокий приоритет и выполняется раньше, чем арифметические операции:</p>
                <code class="code-example">
                    var i = 1;<br>
                    alert( 2 * ++i ); // 4<br>
                    var i = 1;<br>
                    alert( 2 * i++ ); // 2, выполнился раньше но значение вернул старое
                </code>
                <p>При этом, нужно с осторожностью использовать такую запись, потому что в более длинной строке при быстром «вертикальном» чтении кода легко пропустить такой i++, и будет неочевидно, что переменая увеличивается. Три строки, по одному действию в каждой – длиннее, зато нагляднее:</p>
                <code class="code-example">
                    var i = 1;<br>
                    alert( 2 * i );<br>
                    i++;
                </code>
                <h3 class="heading article__subheading">Побитовые операторы</h3>
                <p>Побитовые операторы рассматривают аргументы как 32-разрядные целые числа и работают на уровне их внутреннего двоичного представления. Эти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования. Поддерживаются следующие побитовые операторы:</p>
                <ul class="standart-list">
                    <li><p>AND(и) ( & )</p></li>
                    <li><p>OR(или) ( | )</p></li>
                    <li><p>XOR(побитовое исключающее или) ( ^ )</p></li>
                    <li><p>NOT(не) ( ~ )</p></li>
                    <li><p>LEFT SHIFT(левый сдвиг) ( << )</p></li>
                    <li><p>RIGHT SHIFT(правый сдвиг) ( >> )</p></li>
                    <li><p>ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )</p></li>
                </ul>
                <h3 class="heading article__subheading">Сокращённая арифметика с присваиванием</h3>
                <p>Часто нужно применить оператор к переменной и сохранить результат в ней же, например:</p>
                <code class="code-example">
                    var n = 2;<br>
                    n = n + 5;<br>
                    n = n * 2;
                </code>
                <p>Эту запись можно укоротить при помощи совмещённых операторов, вот так:</p>
                <code class="code-example">
                    var n = 2;<br>
                    n += 5; // теперь n=7 (работает как n = n + 5)<br>
                    n *= 2; // теперь n=14 (работает как n = n * 2)<br>
                    alert( n ); // 14
                </code>
                <p>Так можно сделать для операторов +,-,*,/,% и бинарных <<,>>,>>>,&,|,^. Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций:</p>
                <code class="code-example">
                    var n = 2;<br>
                    n *= 3 + 5;<br>
                    alert( n ); // 16  (n = 2 * 8)
                </code>
                <h3 class="heading article__subheading">Оператор запятая</h3>
                <p>Один из самых необычных операторов – запятая ",". Его можно вызвать явным образом, например:</p>
                <code class="code-example">
                    var a = (5, 6);<br>
                    alert( a );
                </code>
                <p>Запятая позволяет перечислять выражения, разделяя их запятой ','. Каждое из них – вычисляется и отбрасывается, за исключением последнего, которое возвращается. Запятая – единственный оператор, приоритет которого ниже присваивания. В выражении a = (5,6) для явного задания приоритета использованы скобки, иначе оператор '=' выполнился бы до запятой ',', получилось бы (a=5), 6. Обычно он используется в составе более сложных конструкций, чтобы сделать несколько действий в одной строке. Например:</p>
                <code class="code-example">
                    // три операции в одной строке<br>
                    for (a = 1, b = 3, c = a*b; a < 10; a++) {<br>
                    ...<br>
                    }
                </code>
            </article>
            <article class="section__article">
                <h2 class="heading article__title" id="comparison-operators">Операторы сравнения и логические значения</h2>
                <h3 class="heading article__subheading">Логические значения</h3>
                <p>Как и другие операторы, сравнение возвращает значение. Это значение имеет логический тип. Существует всего два логических значения:</p>
                <p>- true – имеет смысл "да", "верно", "истина".</p>
                <p>- false – означает "нет", "неверно", "ложь".</p>
                <p>Например:</p>
                <code class="code-example">
                    alert( 2 > 1 ); // true, верно<br>
                    alert( 2 == 1 ); // false, неверно<br>
                    alert( 2 != 1 ); // true
                </code>
                <p>Логические значения можно использовать и напрямую, присваивать переменным, работать с ними как с любыми другими:</p>
                <code class="code-example">
                    var a = true; // присваивать явно<br>
                    var b = 3 > 4; // или как результат сравнения<br>
                    alert( b ); // false<br>
                    alert( a == b ); // (true == false) неверно, выведет false
                </code>
                <h3 class="heading article__subheading">Сравнение строк</h3>
                <p>Строки сравниваются побуквенно:</p>
                <code class="code-example">
                    alert( 'Б' > 'А' ); // true
                </code>
                <p>Аналогом «алфавита» во внутреннем представлении строк служит кодировка, у каждого символа – свой номер (код). JavaScript использует кодировку Unicode. При этом сравниваются численные коды символов. В частности, код у символа Б больше, чем у А, поэтому и результат сравнения такой. В кодировке Unicode обычно код у строчной буквы больше, чем у прописной. Для корректного сравнения символы должны быть в одинаковом регистре. Поэтому регистр имеет значение:</p>
                <code class="code-example">
                    alert( 'а' > 'Я' ); // true, строчные буквы больше прописных
                </code>
                <p>Если строка состоит из нескольких букв, то сравнение осуществляется как в телефонной книжке или в словаре. Сначала сравниваются первые буквы, потом вторые, и так далее, пока одна не будет больше другой. Иными словами, больше – та строка, которая в телефонной книге была бы на большей странице. Например:</p>
                <p>- Если первая буква первой строки больше – значит первая строка больше, независимо от остальных символов:</p>
                <code class="code-example">
                    alert( 'Банан' > 'Аят' );
                </code>
                <p>- Если одинаковы – сравнение идёт дальше. Здесь оно дойдёт до третьей буквы:</p>
                <code class="code-example">
                    alert( 'Вася' > 'Ваня' ); // true, т.к. 'с' > 'н'
                </code>
                <p>- При этом любая буква больше отсутствия буквы:</p>
                <code class="code-example">
                    alert( 'Привет' > 'Прив' ); // true, так как 'е' больше чем "ничего".
                </code>
                <p>Такое сравнение называется лексикографическим.</p>
                <h3 class="heading article__subheading">Сравнение разных типов</h3>
                <p>При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям. Например:</p>
                <code class="code-example">
                    alert( '2' > 1 ); // true, сравнивается как 2 > 1<br>
                    alert( '01' == 1 ); // true, сравнивается как 1 == 1<br>
                    alert( false == 0 ); // true, false становится числом 0<br>
                    alert( true == 1 ); // true, так как true становится числом 1.
                </code>
                <h3 class="heading article__subheading">Строгое равенство</h3>
                <p>В обычном операторе == есть «проблема» – он не может отличить 0 от false, та же ситуация с пустой строкой:</p>
                <code class="code-example">
                    alert( 0 == false ); // true<br>
                    alert( '' == false ); // true
                </code>
                <p>Это естественное следствие того, что операнды разных типов преобразовались к числу. Пустая строка, как и false, при преобразовании к числу дают 0. Для проверки равенства без преобразования типов используются операторы строгого равенства === (тройное равно) и !==. Если тип разный, то они всегда возвращают false:</p>
                <code class="code-example">
                    alert( 0 === false ); // false, т.к. типы различны
                </code>
                <p>Строгое сравнение предпочтительно, если мы хотим быть уверены, что «сюрпризов» не будет.</p>
                <h3 class="heading article__subheading">Сравнение с null и undefined</h3>
                <p>Проблемы со специальными значениями возможны, когда к переменной применяется операция сравнения > < <= >=, а у неё может быть как численное значение, так и null/undefined. Интуитивно кажется, что null/undefined эквивалентны нулю, но это не так. Они ведут себя по-другому.</p>
                <p>1. Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.</p>
                <p>2. При преобразовании в число null становится 0, а undefined становится NaN.</p>
                <p>В других сравнениях (с участием >,<) их лучше не использовать, так как они ведут себя не как 0.</p>
            </article>
            <article class="section__article">
                <h2 class="heading article__title" id="conditional-operators">Условные операторы: if, "?"</h2>
                <p>Иногда, в зависимости от условия, нужно выполнить различные действия. Для этого используется оператор if. Например:</p>
                <code class="code-example">
                    var year = prompt('В каком году появилась спецификация ECMA-262 5.1?', '');<br>
                    if (year != 2011) alert( 'А вот и неправильно!' );
                </code>
                <h3 class="heading article__subheading">Оператор if</h3>
                <p>Оператор if («если») получает условие, в примере выше это year != 2011. Он вычисляет его, и если результат – true, то выполняет команду. Если нужно выполнить более одной команды – они оформляются блоком кода в фигурных скобках:</p>
                <code class="code-example">
                    if (year != 2011) {<br>
                    alert( 'А вот..' );<br>
                    alert( '..и неправильно!' );<br>
                    }
                </code>
                <h3 class="heading article__subheading">Преобразование к логическому типу</h3>
                <p>Оператор if (...) вычисляет и преобразует выражение в скобках к логическому типу. В логическом контексте:</p>
                <p>1. Число 0, пустая строка "", null и undefined, а также NaN являются false,</p>
                <p>2. Остальные значения – true.</p>
                <p>Например, такое условие никогда не выполнится:</p>
                <code class="code-example">
                    if (0) { // 0 преобразуется к false<br>
                    ...<br>
                    }
                </code>
                <p>А такое – выполнится всегда:</p>
                <code class="code-example">
                    if (1) { // 1 преобразуется к true<br>
                    ...<br>
                    }
                </code>
                <p>Можно и просто передать уже готовое логическое значение, к примеру, заранее вычисленное в переменной:</p>
                <code class="code-example">
                    var cond = (year != 2011); // true/false<br>
                    if (cond) {<br>
                    ...<br>
                    }
                </code>
                <h3 class="heading article__subheading">Неверное условие, else</h3>
                <p>Необязательный блок else ("иначе") выполняется, если условие неверно:</p>
                <code class="code-example">
                    var year = prompt('Введите год появления стандарта ECMA-262 5.1', '');<br>
                    if (year == 2011) {<br>
                    alert( 'Да вы знаток!' );<br>
                    } else {<br>
                    alert( 'А вот и неправильно!' ); // любое значение, кроме 2011<br>
                    }
                </code>
                <h3 class="heading article__subheading">Несколько условий, else if</h3>
                <p>Бывает нужно проверить несколько вариантов условия. Для этого используется блок else if .... Например:</p>
                <code class="code-example">
                    var year = prompt('В каком году появилась спецификация ECMA-262 5.1?', '');<br>
                    if (year < 2011) {<br>
                    alert( 'Это слишком рано..' );<br>
                    } else if (year > 2011) {<br>
                    alert( 'Это поздновато..' );<br>
                    } else {<br>
                    alert( 'Да, точно в этом году!' );<br>
                    }
                </code>
                <p>В примере выше JavaScript сначала проверит первое условие, если оно ложно – перейдет ко второму – и так далее, до последнего else.</p>
                <h3 class="heading article__subheading">Оператор вопросительный знак "?"</h3>
                <p>Иногда нужно в зависимости от условия присвоить переменную. Например:</p>
                <code class="code-example">
                    var access;<br>
                    var age = prompt('Сколько вам лет?', '');<br>
                    if (age > 14) {<br>
                    access = true;<br>
                    } else {<br>
                    access = false;<br>
                    }<br>
                    alert(access);
                </code>
                <p>Оператор вопросительный знак "?" позволяет делать это короче и проще. Он состоит из трех частей:</p>
                <code class="code-example">
                    условие ? значение1 : значение2
                </code>
                <p>Проверяется условие, затем если оно верно – возвращается значение1, если неверно – значение2, например:</p>
                <code class="code-example">
                    access = (age > 14) ? true : false;
                </code>
                <p>Оператор '?' выполняется позже большинства других, в частности – позже сравнений, поэтому скобки можно не ставить:</p>
                <code class="code-example">
                    access = age > 14 ? true : false;
                </code>
                <p>Вопросительный знак – единственный оператор, у которого есть три аргумента, в то время как у обычных операторов их один-два. Поэтому его называют "тернарный оператор".</p>
                <h3 class="heading article__subheading">Несколько операторов "?"</h3>
                <p>Последовательность операторов '?' позволяет вернуть значение в зависимости не от одного условия, а от нескольких. Например:</p>
                <code class="code-example">
                    var age = prompt('возраст?', 18);<br>
                    var message = (age < 3) ? 'Здравствуй, малыш!' :<br>
                    (age < 18) ? 'Привет!' :<br>
                    (age < 100) ? 'Здравствуйте!' :<br>
                    'Какой необычный возраст!';<br>
                    alert( message );
                </code>
                <p>Вопросительный знак проверяет сначала age < 3, если верно – возвращает 'Здравствуй, малыш!', если нет – идет за двоеточие и проверяет age < 18. Если это верно – возвращает 'Привет!', иначе проверка age < 100 и 'Здравствуйте!'… И наконец, если ничего из этого не верно, то 'Какой необычный возраст!'. То же самое через if..else:</p>
                <code class="code-example">
                    if (age < 3) {<br>
                    message = 'Здравствуй, малыш!';<br>
                    } else if (age < 18) {<br>
                    message = 'Привет!';<br>
                    } else if (age < 100) {<br>
                    message = 'Здравствуйте!';<br>
                    } else {<br>
                    message = 'Какой необычный возраст!';<br>
                    }
                </code>
                <h3 class="heading article__subheading">Нетрадиционное использование "?"</h3>
                <p>Иногда оператор вопросительный знак "?" используют как замену if:</p>
                <code class="code-example">
                    var company = prompt('Какая компания создала JavaScript?', '');<br>
                    (company == 'Netscape') ?<br>
                    alert('Да, верно') : alert('Неправильно');
                </code>
                <p>Работает это так: в зависимости от условия, будет выполнена либо первая, либо вторая часть после "?". Результат выполнения не присваивается в переменную, так что пропадёт (впрочем, alert ничего не возвращает). Рекомендуется не использовать вопросительный знак таким образом. Несмотря на то, что с виду такая запись короче if, она является существенно менее читаемой. Вот, для сравнения, то же самое с if:</p>
                <code class="code-example">
                    var company = prompt('Какая компания создала JavaScript?', '');<br>
                    if (company == 'Netscape') {<br>
                    alert('Да, верно');<br>
                    } else {<br>
                    alert('Неправильно');<br>
                    }
                </code>
            </article>
            <article class="section__article">
                <h2 class="article__title" id="logic-operators">Логические операторы</h2>
                <p>Для операций над логическими значениями в JavaScript есть || (ИЛИ), && (И) и ! (НЕ). Хоть они и называются "логическими", но в JavaScript могут применяться к значениям любого типа и возвращают также значения любого типа.</p>
                <h3 class="heading article__subheading">|| (ИЛИ)</h3>
                <p>Оператор ИЛИ выглядит как двойной символ вертикальной черты:</p>
                <code class="code-example">
                    result = a || b;
                </code>
                <p>Логическое ИЛИ в классическом программировании работает следующим образом: "если хотя бы один из аргументов true, то возвращает true, иначе – false". Получается следующая "таблица результатов":</p>
                <code class="code-example">
                    alert( true || true ); // true<br>
                    alert( false || true ); // true<br>
                    alert( true || false ); // true<br>
                    alert( false || false ); // false
                </code>
                <p>Если значение не логического типа – то оно к нему приводится в целях вычислений. Например, число 1 будет воспринято как true, а 0 – как false:</p>
                <code class="code-example">
                    if (1 || 0) { // сработает как if( true || false )<br>
                    alert( 'верно' );<br>
                    }
                </code>
                <p>Обычно оператор ИЛИ используется в if, чтобы проверить, выполняется ли хотя бы одно из условий, например:</p>
                <code class="code-example">
                    var hour = 9;<br>
                    if (hour < 10 || hour > 18) {<br>
                    alert( 'Офис до 10 или после 18 закрыт' );<br>
                    }
                </code>
                <p>Можно передать и больше условий:</p>
                <code class="code-example">
                    var hour = 12,<br>
                    isWeekend = true;<br>
                    if (hour < 10 || hour > 18 || isWeekend) {<br>
                    alert( 'Офис до 10 или после 18 или в выходной закрыт' );<br>
                    }
                </code>
                <h3 class="heading article__subheading">Короткий цикл вычислений</h3>
                <p>JavaScript вычисляет несколько ИЛИ слева направо. При этом, чтобы экономить ресурсы, используется так называемый "короткий цикл вычисления". Допустим, вычисляются несколько ИЛИ подряд: a || b || c || .... Если первый аргумент – true, то результат заведомо будет true (хотя бы одно из значений – true), и остальные значения игнорируются. Это особенно заметно, когда выражение, переданное в качестве второго аргумента, имеет сторонний эффект – например, присваивает переменную. При запуске примера ниже присвоение x не произойдёт:</p>
                <code class="code-example">
                    var x;<br>
                    true || (x = 1);<br>
                    alert(x); // undefined, x не присвоен
                </code>
                <p>А в примере ниже первый аргумент – false, так что ИЛИ попытается вычислить второй, запустив тем самым присваивание:</p>
                <code class="code-example">
                    var x;<br>
                    false || (x = 1);<br>
                    alert(x); // 1
                </code>
                <h3 class="heading article__subheading">Значение ИЛИ</h3>
                <p>Оператор ИЛИ вычисляет ровно столько значений, сколько необходимо – до первого true. При этом оператор ИЛИ возвращает то значение, на котором остановились вычисления. Причём, не преобразованное к логическому типу. Например:</p>
                <code class="code-example">
                    alert( 1 || 0 ); // 1<br>
                    alert( true || 'неважно что' ); // true<br>
                    alert( null || 1 ); // 1<br>
                    alert( undefined || 0 ); // 0
                </code>
                <p>Это используют, в частности, чтобы выбрать первое "истинное" значение из списка:</p>
                <code class="code-example">
                    var undef; // переменная не присвоена, т.е. равна undefined<br>
                    var zero = 0;<br>
                    var emptyStr = "";<br>
                    var msg = "Привет!";<br>
                    var result = undef || zero || emptyStr || msg || 0;<br>
                    alert( result ); // выведет "Привет!" - первое значение, которое является true
                </code>
                <p>Если все значения "ложные", то || возвратит последнее из них:</p>
                <code class="code-example">
                    alert( undefined || '' || false || 0 ); // 0
                </code>
                <p>Итак, оператор || вычисляет операнды слева направо до первого true и возвращает его, а если все ложные – то последнее значение. Иначе можно сказать, что "|| запинается на правде".</p>
                <h3 class="heading article__subheading">&& (И)</h3>
                <p>Оператор И пишется как два амперсанда &&:</p>
                <code class="code-example">
                    result = a && b;
                </code>
                <p>В классическом программировании И возвращает true, если оба аргумента истинны, а иначе – false:</p>
                <code class="code-example">
                    alert( true && true ); // true<br>
                    alert( false && true ); // false<br>
                    alert( true && false ); // false<br>
                    alert( false && false ); // false
                </code>
                <p>Пример с if:</p>
                <code class="code-example">
                    var hour = 12,<br>
                    minute = 30;<br>
                    if (hour == 12 && minute == 30) {<br>
                    alert( 'Время 12:30' );<br>
                    }
                </code>
                <p>Как и в ИЛИ, в И допустимы любые значения:</p>
                <code class="code-example">
                    if (1 && 0) { // вычислится как true && false<br>
                    alert( 'не сработает, т.к. условие ложно' );<br>
                    }
                </code>
                <p>К И применим тот же принцип "короткого цикла вычислений", но немного по-другому, чем к ИЛИ. Если левый аргумент – false, оператор И возвращает его и заканчивает вычисления. Иначе – вычисляет и возвращает правый аргумент. Например:</p>
                <code class="code-example">
                    // Первый аргумент - true,<br>
                    // Поэтому возвращается второй аргумент<br>
                    alert( 1 && 0 ); // 0<br>
                    alert( 1 && 5 ); // 5<br>
                    // Первый аргумент - false,<br>
                    // Он и возвращается, а второй аргумент игнорируется<br>
                    alert( null && 5 ); // null<br>
                    alert( 0 && "не важно" ); // 0
                </code>
                <p>Можно передать и несколько значений подряд, при этом возвратится первое "ложное" (на котором остановились вычисления), а если его нет – то последнее:</p>
                <code class="code-example">
                    alert( 1 && 2 && null && 3 ); // null<br>
                    alert( 1 && 2 && 3 ); // 3
                </code>
                <p>Итак, оператор && вычисляет операнды слева направо до первого false и возвращает его, а если все истинные – то последнее значение. Иначе можно сказать, что "&& запинается на лжи".</p>
                <p>Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше. Поэтому в следующем коде сначала будет вычислено правое И: 1 && 0 = 0, а уже потом – ИЛИ.</p>
                <code class="code-example">
                    alert( 5 || 1 && 0 ); // 5
                </code>
                <h3 class="heading article__subheading">! (НЕ)</h3>
                <p>Оператор НЕ – самый простой. Он получает один аргумент. Синтаксис:</p>
                <code class="code-example">
                    var result = !value;
                </code>
                <p>Действия !:</p>
                <p>1. Сначала приводит аргумент к логическому типу true/false.</p>
                <p>2. Затем возвращает противоположное значение.</p>
                <code class="code-example">
                    alert( !true ); // false<br>
                    alert( !0 ); // true
                </code>
                <p>В частности, двойное НЕ используют для преобразования значений к логическому типу:</p>
                <code class="code-example">
                    alert( !!"строка" ); // true<br>
                    alert( !!null ); // false
                </code>
            </article>
        </section>

        <section class="section">
            <h1 class="heading section__title" id="functions">Функции</h1>
            <article class="section__article">
                <h2 class="heading article__title" id="while-for-cycles">Циклы while, for</h2>
                <h3 class="heading article__subheading">Цикл while</h3>
                <p>Цикл while имеет вид:</p>
                <code class="code-example">
                    while (condition is true) {<br>
                        // код, тело цикла<br>
                    }
                </code>
                <p>Пока условие верно – выполняется код из тела цикла. Условие в скобках интерпретируется как логическое значение, поэтому вместо while (i!=0) обычно пишут while (i):</p>
                <code class="code-example">
                    var i = 3;<br>
                    while (i) { // при i, равном 0, значение в скобках будет false и цикл остановится<br>
                    alert( i );<br>
                    i--;<br>
                    }
                </code>
                <h3 class="heading article__subheading">Цикл do…while</h3>
                <p>Проверку условия можно поставить под телом цикла, используя специальный синтаксис do..while:</p>
                <code class="code-example">
                    do {<br>
                    // тело цикла<br>
                    } while (condition is true);
                </code>
                <p>Цикл, описанный, таким образом, сначала выполняет тело, а затем проверяет условие. Например:</p>
                <code class="code-example">
                    var i = 0;<br>
                    do {<br>
                    alert( i );<br>
                    i++;<br>
                    } while (i < 3);
                </code>
                <h3 class="heading article__subheading">Цикл for</h3>
                <code class="code-example">
                    for (начало; условие; шаг) {<br>
                    // ... тело цикла ...<br>
                    }
                </code>
                <p>Пример цикла, который выполняет alert(i) для i от 0 до 2 включительно (до 3):</p>
                <code class="code-example">
                    var i;<br>
                    for (i = 0; i < 3; i++) {<br>
                    alert( i );<br>
                    }
                </code>
                <ul class="standart-list">
                    <li><p>Начало: i=0.</p></li>
                    <li><p>Условие: i<3.</p></li>
                    <li><p>Шаг: i++.</p></li>
                    <li><p>Тело: alert(i), т.е. код внутри фигурных скобок (они не обязательны, если только одна операция)</p></li>
                </ul>
                <p>Цикл выполняется так:</p>
                <ul class="standart-list">
                    <li><p>Начало: i=0 выполняется один-единственный раз, при заходе в цикл.</p></li>
                    <li><p>Условие: i<3 проверяется перед каждой итерацией и при входе в цикл, если оно нарушено, то происходит выход.</p></li>
                    <li><p>Тело: alert(i).</p></li>
                    <li><p>Шаг: i++ выполняется после тела на каждой итерации, но перед проверкой условия.</p></li>
                    <li><p>Идти на шаг 2.</p></li>
                </ul>
                <p>Иными словами, поток выполнения: начало → (если условие → тело → шаг) → (если условие → тело → шаг) → … и так далее, пока верно условие.</p>
                <p>В цикле также можно определить переменную. Эта переменная будет видна и за границами цикла, в частности, после окончания цикла i станет равно 3.</p>
                <code class="code-example">
                    for (var i = 0; i < 3; i++) {<br>
                    alert(i); // 0, 1, 2<br>
                    }
                </code>
            </article>
        </section>

        <script>
            var scroll = new SmoothScroll('a[href*="#"]');
        </script>
        <button class="cd-top">Top</button>
		<script src="scripts/jquery.min.js"></script>
		<script src="scripts/main.js"></script>
        
    </body>
</html>